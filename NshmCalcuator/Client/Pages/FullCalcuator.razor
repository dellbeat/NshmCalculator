@page "/"
@using NshmCalculator.Shared
@using Color = BootstrapBlazor.Components.Color
@inject ISyncLocalStorageService LocalStorage
@inject ToastService ToastService

<PageTitle>逆水寒手游属性收益计算器</PageTitle>
<ValidateForm @ref="ValidateForm" Model="@_baseInfo" OnValidSubmit="@OnCalculateBase">
    <Divider Text="玩家数值" Alignment="Alignment.Center" />
    <div class="row g-3">
        <div class="col-6 col-md-4">
            <BootstrapInputGroup>
                <Tooltip Title="面板内/外功攻击力" Placement="Placement.Right" Trigger="Click">
                    <BootstrapInputGroupLabel DisplayText="攻击*" />
                </Tooltip>
                <BootstrapInput @bind-Value="@_baseInfo.PlayerBaseAttack" />
            </BootstrapInputGroup>
        </div>
        <div class="col-6 col-md-4">
            <BootstrapInputGroup>
                <BootstrapInputGroupLabel DisplayText="破防" />
                <BootstrapInput @bind-Value="@_baseInfo.PlayerBaseBreakDefense" />
            </BootstrapInputGroup>
        </div>
        <div class="col-6 col-md-4">
            <BootstrapInputGroup>
                <Tooltip Title="技能属性对应的的元素攻击的值" Placement="Placement.Right" Trigger="Click">
                    <BootstrapInputGroupLabel DisplayText="元素攻击*" />
                </Tooltip>
                <BootstrapInput @bind-Value="@_baseInfo.PlayerBaseElementAttack" />
            </BootstrapInputGroup>
        </div>
        <div class="col-6 col-md-4">
            <BootstrapInputGroup>
                <Tooltip Title="若受击方为boss或木桩，则此处输入首领克制的数字值，即斜杠左边的值" Placement="Placement.Right" Trigger="Click">
                <BootstrapInputGroupLabel DisplayText="克制数值" />
                </Tooltip>
                <BootstrapInput @bind-Value="@_baseInfo.PlayerBaseRestraint" />
            </BootstrapInputGroup>
        </div>
        <div class="col-6 col-md-4">
            <BootstrapInputGroup>
                <BootstrapInputGroupLabel DisplayText="命中" />
                <BootstrapInput @bind-Value="@_baseInfo.PlayerBaseHit" />
            </BootstrapInputGroup>
        </div>
        <div class="col-6 col-md-4">
            <BootstrapInputGroup>
                <BootstrapInputGroupLabel DisplayText="会心" />
                <BootstrapInput @bind-Value="@_baseInfo.PlayerBaseCriticalHits" />
            </BootstrapInputGroup>
        </div>
        <div class="col-6 col-md-4">
            <BootstrapInputGroup>
                <BootstrapInputGroupLabel DisplayText="会伤(%)" />
                <BootstrapInput @bind-Value="@_baseInfo.PlayerBaseCriticalRate" />
            </BootstrapInputGroup>
        </div>
        <div class="col-6 col-md-4">
            <BootstrapInputGroup>
                <Tooltip Title="例如：内功3金提供5%的会心率，则此处输入5" Placement="Placement.Right" Trigger="Click">
                <BootstrapInputGroupLabel DisplayText="周天会心率(%)" />
                </Tooltip>
                <BootstrapInput @bind-Value="@_baseInfo.PlayerBaseZtCriticalHitsRate"/>
            </BootstrapInputGroup>
        </div>
        <div class="col-6 col-md-4">
            <BootstrapInputGroup>
                <Tooltip Title="若受击方为boss或木桩，则此处输入首领克制的百分比值，即斜杠右边的值" Placement="Placement.Right" Trigger="Click">
                    <BootstrapInputGroupLabel DisplayText="克制百分比(%)"/>
                </Tooltip>
                <BootstrapInput @bind-Value="@_baseInfo.PlayerBaseRestrainedRate"/>
            </BootstrapInputGroup>
        </div>
    </div>
    <Divider Text="敌方数值" Alignment="Alignment.Center" />
    <div class="row g-3">
        <div class="col-6 col-lg-6 col-sm-6">
            <BootstrapInputGroup>
                <BootstrapInputGroupLabel DisplayText="敌方防御" />
                <BootstrapInput @bind-Value="@_baseInfo.EnemyDefense" />
            </BootstrapInputGroup>
        </div>
        <div class="col-6 col-lg-6 col-sm-6">
            <BootstrapInputGroup>
                <BootstrapInputGroupLabel DisplayText="敌方格挡" />
                <BootstrapInput @bind-Value="@_baseInfo.EnemyBlock" />
            </BootstrapInputGroup>
        </div>
        <div class="col-12" style="text-align: center">
            <BootstrapLabel Value="满命中：" />
            <Tag Color="Color.Success">
                @_baseInfo.FullHit.ToString()
            </Tag>
        </div>
    </div>
    <Divider Text="玩家新增数值（选填）" Alignment="Alignment.Center" />
    <div class="row g-3">
        <div class="col-6 col-md-3">
            <BootstrapInputGroup>
                <Tooltip Title="输入的是平均攻击的变化，如果是单独提升最大/最小攻击则需要除以2" Placement="Placement.Right" Trigger="Click">
                    <BootstrapInputGroupLabel DisplayText="新增攻击"/>
                </Tooltip>
                <BootstrapInput @bind-Value="@_baseInfo.IncreaseAttack"/>
            </BootstrapInputGroup>
        </div>
        <div class="col-6 col-md-3">
            <BootstrapInputGroup>
                <BootstrapInputGroupLabel DisplayText="新增克制" />
                <BootstrapInput @bind-Value="@_baseInfo.IncreaseRestraint" />
            </BootstrapInputGroup>
        </div>
        <div class="col-6 col-md-3">
            <BootstrapInputGroup>
                <BootstrapInputGroupLabel DisplayText="新增属性攻击" />
                <BootstrapInput @bind-Value="@_baseInfo.IncreaseElementAttack" />
            </BootstrapInputGroup>
        </div>
        <div class="col-6 col-md-3">
            <BootstrapInputGroup>
                <BootstrapInputGroupLabel DisplayText="新增破防" />
                <BootstrapInput @bind-Value="@_baseInfo.IncreaseBreakDefense" />
            </BootstrapInputGroup>
        </div>
        <div class="col-6 col-md-3">
            <BootstrapInputGroup>
                <BootstrapInputGroupLabel DisplayText="新增命中" />
                <BootstrapInput @bind-Value="@_baseInfo.IncreaseHit" />
            </BootstrapInputGroup>
        </div>
        <div class="col-6 col-md-3">
            <BootstrapInputGroup>
                <BootstrapInputGroupLabel DisplayText="新增会心" />
                <BootstrapInput @bind-Value="@_baseInfo.IncreaseCriticalHits" />
            </BootstrapInputGroup>
        </div>
        <div class="col-6 col-md-3">
            <BootstrapInputGroup>
                <BootstrapInputGroupLabel DisplayText="新增会伤率(%)" />
                <BootstrapInput @bind-Value="@_baseInfo.IncreaseCriticalRate" />
            </BootstrapInputGroup>
        </div>
        <div class="col-12" style="text-align:center">
            <Button ButtonType="@ButtonType.Submit" Text="计算"></Button>
        </div>
        <div class="col-6 col-md-3" style="text-align: center">
            <BootstrapLabel Value="未会心伤害："/>
            <Tag Color="Color.Primary">
                @_baseInfo.NonCriticalDamageFunValue.ToString("0.00")
            </Tag>
        </div>
        <div class="col-6 col-md-3" style="text-align: center">
            <BootstrapLabel Value="含命中会心伤害期望：" />
            <Tag Color="Color.Primary">
                @_baseInfo.CriticalDamageFunValue.ToString("0.00")
            </Tag>
        </div>
        <div class="col-6 col-md-3" style="text-align: center">
            <BootstrapLabel Value="实际命中率：" />
            <Tag Color="Color.Primary">
                @_baseInfo.HitRate.ToString("P2")
            </Tag>
        </div>
        <div class="col-6 col-md-3" style="text-align: center">
            <BootstrapLabel Value="实际会心率：" />
            <Tag Color="Color.Primary">
                @_baseInfo.CalCriticalRate.ToString("P2")
            </Tag>
        </div>
        <div class="col-12" style="text-align: center">
            <BootstrapLabel Value="@LastTimeStr" />
        </div>
    </div>
</ValidateForm>
<Chart @ref="YieldsChart" OnInitAsync="() => OnInit()" Width="100%" Height="400px" />

@code {

    private FullPlayerInfo _baseInfo = new();
    private ValidateForm? ValidateForm { get; set; }
    private Chart YieldsChart { get; set; }
    private List<List<double>> _yieldList { get; set; }
    private readonly int BaseIncreaseNum = 40;
    private static string[] _labelArray = new[] { "攻击", "元素攻击", "破防", "命中", "会心", "首克数值" };

    private readonly ToastOption _warningOption = new ToastOption()
        {
            Category = ToastCategory.Warning,
            IsAutoHide = false,
            Title = "Notification",
            Content = "计算进程出现异常，建议检查输入内容；如有必要可与作者联系"
        };

    private string? LastTimeStr => _baseInfo.LastCalTime == null ? null : $"上次计算时间:{(((DateTime)_baseInfo.LastCalTime).ToString("yyyy-MM-dd HH:mm:ss"))}";

    protected override void OnInitialized()
    {
        base.OnInitialized();
        GetInfo();
    }

    private void SaveInfo()
    {
        LocalStorage.SetItem("fullBaseInfo", _baseInfo);
        LocalStorage.SetItem("yieldList", _yieldList);
    }

    private void GetInfo()
    {
        _baseInfo = LocalStorage.GetItem<FullPlayerInfo>("fullBaseInfo") ?? new();
        if (_baseInfo.EnemyCriticalDefense == 0)
        {
            _baseInfo.EnemyCriticalDefense = 200;
        }
        _yieldList = LocalStorage.GetItem<List<List<double>>>("yieldList") ?? new List<List<double>>();
        if (_yieldList.Count != 6)//需要保证有五个列表，置空即可
        {
            for (int i = _yieldList.Count; i < 6; i++)
            {
                _yieldList.Add(new List<double>());
            }
        }
    }

    /// <summary>
    /// 获取无首领加成的伤害
    /// </summary>
    /// <param name="attackOfPlayer">玩家攻击</param>
    /// <param name="restraintNum">玩家克制数值</param>
    /// <param name="elementAttackOfPlayer">玩家元素攻击</param>
    /// <param name="breakDefenseOfPlayer">玩家破防值</param>
    /// <param name="defenseOfMonster">敌方防御</param>
    /// <param name="resistOfMonster">敌方抵御</param>
    /// <param name="rate1">系数1</param>
    /// <param name="rate2">系数2</param>
    /// <param name="remainAirShield">剩余气盾，由于PVE目前暂不考虑该参数，故默认为0</param>
    private double CalculateBaseDamage(int attackOfPlayer, int restraintNum, int elementAttackOfPlayer, int breakDefenseOfPlayer, int defenseOfMonster, int resistOfMonster, double rate1, double rate2, int remainAirShield = 0)
    {
        double resistanceRemission = resistOfMonster * 1.0 / (resistOfMonster + 530);//敌方（怪物）抗性减免
        int remainDefense = defenseOfMonster - breakDefenseOfPlayer;//敌方剩余防御，理论不会小于0，不做特别判断
        if (remainDefense < 0)
        {
            remainDefense = 0;
        }
        double defenseRemission = remainDefense * 1.0 / (remainDefense + 2860);//防御减免

        double baseDamage = ((rate1 + rate2 * (attackOfPlayer - remainAirShield + restraintNum - resistOfMonster)) * (1 - defenseRemission) + rate2 * elementAttackOfPlayer * (1 - resistanceRemission));//无首领克制加成的伤害

        return baseDamage;
    }

    /// <summary>获取未会心伤害</summary>
    /// <param name="baseDamage">无首领克制的伤害</param>
    /// <param name="restrainedRate">首领克制百分比</param>
    private double CalculateNonCriticalDamage(double baseDamage, double restrainedRate)
    {
        return baseDamage * (1 + restrainedRate);
    }


    /// <summary>
    /// 获取会心伤害
    /// </summary>
    /// <param name="nonCriticalDamage">未会心伤害</param>
    /// <param name="hitNum">命中</param>
    /// <param name="blockOfMonster">敌方格挡</param>
    /// <param name="criticalSubRate">会心伤害百分比-100%</param>
    /// <param name="criticalHit">会心</param>
    /// <param name="criticalDefenseOfMonster">敌方会心抵抗</param>
    /// <param name="extraCriticalRate">内功提供的额外会心率</param>
    /// <param name="calCriticalRate">计算的会心率结果</param>
    private double CalculateCriticalDamage(double nonCriticalDamage, int hitNum, int blockOfMonster, double criticalSubRate, int criticalHit, int criticalDefenseOfMonster, double extraCriticalRate, out double calCriticalRate)
    {
        double panelHitRateOfPlayer = (143 * hitNum * 1.0 / (hitNum + 713) / 100 is double panelNum && panelNum > 1 ? 1 : panelNum);//玩家[攻击方]面板命中率
        double panelDefenseRateOfMonster = 143 * 1.0 * blockOfMonster / (blockOfMonster + 713) / 100;//敌方[受击方]面板格挡率Da
        double hitRateOfPlayer = 0.95 + panelHitRateOfPlayer - panelDefenseRateOfMonster;//玩家对敌方命中率
        if (hitRateOfPlayer > 1)
        {
            hitRateOfPlayer = 1;
        }
        int remainCritical = (criticalHit - criticalDefenseOfMonster);//剩余会心
        double criticalRate = (115 * remainCritical + 90) * 1.0 / (remainCritical + 940) / 100 + extraCriticalRate;//会心率
        calCriticalRate = criticalRate;
        double criticalDamage = nonCriticalDamage * hitRateOfPlayer * (1 + criticalSubRate * criticalRate) + 0.5 * nonCriticalDamage * (1 - hitRateOfPlayer);//会心伤害【未计算技能倍数】

        return criticalDamage;
    }

    /// <summary>
    /// 普通计算攻击力
    /// </summary>
    private Task OnCalculateBase(EditContext context)
    {
        double skillRate = 1;//技能倍率
        double rate2 = 0.324;//系数2，暂定为固定值
        double rate1 = rate2 * 923;//系数1

        try
        {
            _baseInfo.BaseDamageFunValue = CalculateBaseDamage(_baseInfo.PlayerBaseAttack, _baseInfo.PlayerBaseRestraint, _baseInfo.PlayerBaseElementAttack, _baseInfo.PlayerBaseBreakDefense, _baseInfo.EnemyDefense, _baseInfo.EnemyResist, rate1, rate2);
            _baseInfo.NonCriticalDamageFunValue = CalculateNonCriticalDamage(_baseInfo.BaseDamageFunValue, _baseInfo.PlayerBaseRestrainedRate / 100.0);
            _baseInfo.CriticalDamageFunValue = CalculateCriticalDamage(_baseInfo.NonCriticalDamageFunValue, _baseInfo.PlayerBaseHit, _baseInfo.EnemyBlock, (_baseInfo.PlayerBaseCriticalRate - 100) / 100.0, _baseInfo.PlayerBaseCriticalHits, _baseInfo.EnemyCriticalDefense, _baseInfo.PlayerBaseZtCriticalHitsRate / 100.0, out double newRate);
            _baseInfo.HitRate = (95 + 143 * (_baseInfo.PlayerBaseHit + _baseInfo.IncreaseHit) * 1.0 / (_baseInfo.PlayerBaseHit + _baseInfo.IncreaseHit + 713) - 143 * _baseInfo.EnemyBlock * 1.0 / (_baseInfo.EnemyBlock + 713)) / 100;
            _baseInfo.CalCriticalRate = newRate;
            if (_baseInfo.HitRate > 1)
            {
                _baseInfo.HitRate = 1;
            }

            double oldAttack = _baseInfo.BaseDamageFunValue;
            double oldElement = _baseInfo.BaseDamageFunValue;
            double oldBreakDefense = _baseInfo.BaseDamageFunValue;
            double oldHit = _baseInfo.CriticalDamageFunValue;
            double oldCritical = _baseInfo.CriticalDamageFunValue;
            double oldRestraint = _baseInfo.BaseDamageFunValue;

            for (int i = 0; i < _yieldList.Count; i++)
            {
                _yieldList[i].Clear();
            }

            for (int i = 1; i <= 20; i++)
            {
                _yieldList[0].Add((CalculateBaseDamage(_baseInfo.PlayerBaseAttack + i * BaseIncreaseNum, _baseInfo.PlayerBaseRestraint, _baseInfo.PlayerBaseElementAttack, _baseInfo.PlayerBaseBreakDefense, _baseInfo.EnemyDefense, _baseInfo.EnemyResist, rate1, rate2) - oldAttack) / oldAttack);
                oldAttack = CalculateBaseDamage(_baseInfo.PlayerBaseAttack + i * BaseIncreaseNum, _baseInfo.PlayerBaseRestraint, _baseInfo.PlayerBaseElementAttack, _baseInfo.PlayerBaseBreakDefense, _baseInfo.EnemyDefense, _baseInfo.EnemyResist, rate1, rate2);

                _yieldList[1].Add((CalculateBaseDamage(_baseInfo.PlayerBaseAttack, _baseInfo.PlayerBaseRestraint, _baseInfo.PlayerBaseElementAttack + i * BaseIncreaseNum, _baseInfo.PlayerBaseBreakDefense, _baseInfo.EnemyDefense, _baseInfo.EnemyResist, rate1, rate2) - oldElement) / oldElement);
                oldElement = CalculateBaseDamage(_baseInfo.PlayerBaseAttack, _baseInfo.PlayerBaseRestraint, _baseInfo.PlayerBaseElementAttack + i * BaseIncreaseNum, _baseInfo.PlayerBaseBreakDefense, _baseInfo.EnemyDefense, _baseInfo.EnemyResist, rate1, rate2);

                _yieldList[2].Add((CalculateBaseDamage(_baseInfo.PlayerBaseAttack, _baseInfo.PlayerBaseRestraint, _baseInfo.PlayerBaseElementAttack, _baseInfo.PlayerBaseBreakDefense + i * BaseIncreaseNum, _baseInfo.EnemyDefense, _baseInfo.EnemyResist, rate1, rate2) - oldBreakDefense) / oldBreakDefense);
                oldBreakDefense = CalculateBaseDamage(_baseInfo.PlayerBaseAttack, _baseInfo.PlayerBaseRestraint, _baseInfo.PlayerBaseElementAttack, _baseInfo.PlayerBaseBreakDefense + i * BaseIncreaseNum, _baseInfo.EnemyDefense, _baseInfo.EnemyResist, rate1, rate2);

                _yieldList[3].Add((CalculateCriticalDamage(_baseInfo.NonCriticalDamageFunValue, _baseInfo.PlayerBaseHit + i * BaseIncreaseNum, _baseInfo.EnemyBlock, (_baseInfo.PlayerBaseCriticalRate - 100) / 100.0, _baseInfo.PlayerBaseCriticalHits, _baseInfo.EnemyCriticalDefense, _baseInfo.PlayerBaseZtCriticalHitsRate / 100.0, out _) - oldHit) / oldHit);
                oldHit = CalculateCriticalDamage(_baseInfo.NonCriticalDamageFunValue, _baseInfo.PlayerBaseHit + i * BaseIncreaseNum, _baseInfo.EnemyBlock, (_baseInfo.PlayerBaseCriticalRate - 100) / 100.0, _baseInfo.PlayerBaseCriticalHits, _baseInfo.EnemyCriticalDefense, _baseInfo.PlayerBaseZtCriticalHitsRate / 100.0, out _);

                _yieldList[4].Add((CalculateCriticalDamage(_baseInfo.NonCriticalDamageFunValue, _baseInfo.PlayerBaseHit, _baseInfo.EnemyBlock, (_baseInfo.PlayerBaseCriticalRate - 100) / 100.0, _baseInfo.PlayerBaseCriticalHits + i * BaseIncreaseNum, _baseInfo.EnemyCriticalDefense, _baseInfo.PlayerBaseZtCriticalHitsRate / 100.0, out _) - oldCritical) / oldCritical);
                oldCritical = CalculateCriticalDamage(_baseInfo.NonCriticalDamageFunValue, _baseInfo.PlayerBaseHit, _baseInfo.EnemyBlock, (_baseInfo.PlayerBaseCriticalRate - 100) / 100.0, _baseInfo.PlayerBaseCriticalHits + i * BaseIncreaseNum, _baseInfo.EnemyCriticalDefense, _baseInfo.PlayerBaseZtCriticalHitsRate / 100.0, out _);

                _yieldList[5].Add((CalculateBaseDamage(_baseInfo.PlayerBaseAttack, _baseInfo.PlayerBaseRestraint + i * BaseIncreaseNum, _baseInfo.PlayerBaseElementAttack, _baseInfo.PlayerBaseBreakDefense, _baseInfo.EnemyDefense, _baseInfo.EnemyResist, rate1, rate2) - oldRestraint) / oldRestraint);
                oldRestraint = CalculateBaseDamage(_baseInfo.PlayerBaseAttack, _baseInfo.PlayerBaseRestraint + i * BaseIncreaseNum, _baseInfo.PlayerBaseElementAttack, _baseInfo.PlayerBaseBreakDefense, _baseInfo.EnemyDefense, _baseInfo.EnemyResist, rate1, rate2);
            }
            YieldsChart.Update(ChartAction.Update);
            SaveInfo();
        }
        catch (Exception e)
        {
            ToastService.Show(_warningOption);
        }

        return Task.CompletedTask;
    }

    private Task<ChartDataSource> OnInit()
    {
        var ds = new ChartDataSource
            {
                Options =
            {
                Title = $"提升收益率曲线(每提升{BaseIncreaseNum}点的千分比)",
                X =
                {
                    Title = "提升数值"
                },
                Y =
                {
                    Title = "收益率(‰)"
                }
            }
            };
        List<string> xLabels = new List<string>();
        for (int i = 1; i <= 20; i++)
        {
            xLabels.Add((i * BaseIncreaseNum).ToString());
        }
        ds.Labels = xLabels;
        for (int i = 0; i < _labelArray.Length; i++)
        {
            ds.Data.Add(new ChartDataset()
                {
                    Label = $"{_labelArray[i]}提升收益率(‰)",
                    Data = _yieldList[i].Select(s => s * 1000).Cast<object>()
                });
        }

        return Task.FromResult(ds);
    }
}
